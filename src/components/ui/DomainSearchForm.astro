---
import Message from './Message.astro';

interface Registry {
	code: string;
	name: string;
	placeholder: string;
	extension: string;
}

interface Props {
	registries: Registry[];
}

const { registries } = Astro.props;
const defaultRegistry = registries[0];
---

<div class="w-full max-w-2xl">
	<form 
		class="domain-search-form flex flex-col sm:flex-row gap-0 w-full" 
		role="search" 
		aria-label="Recherche de domaine"
		data-registries={JSON.stringify(registries)}
	>
		<div class="flex flex-1 bg-white rounded-t-lg sm:rounded-l-lg sm:rounded-tr-none min-w-0 shadow-xl">
			<label for="domain-search" class="sr-only">
				Chercher un domaine
			</label>
			<input 
				type="text" 
				id="domain-search"
				name="domain"
				required
				minlength="2"
				maxlength="63"
				placeholder={defaultRegistry.placeholder}
				class="flex-1 min-w-0 px-3 sm:px-6 py-4 md:py-5 text-(--color-secondary) placeholder:text-gray-400 text-sm sm:text-base md:text-lg focus:outline-none rounded-tl-lg sm:rounded-l-lg transition-opacity duration-300"
				aria-label="Nom de domaine"
			/>
			<div class="relative flex items-center shrink-0">
				<select 
					id="registry-select"
					class="appearance-none px-2 sm:px-4 py-4 md:py-5 text-(--color-secondary) font-semibold text-sm sm:text-base md:text-lg bg-(--color-tertiary) cursor-pointer hover:bg-gray-50 focus:outline-none focus:bg-gray-50 transition-colors pr-8 sm:pr-10 w-[80px] sm:w-auto sm:min-w-[100px]"
					aria-label="Sélectionner un registre de domaine"
				>
					{registries.map(registry => (
						<option value={registry.extension} data-placeholder={registry.placeholder}>
							{registry.extension}
						</option>
					))}
				</select>
				<!-- Custom dropdown arrow -->
				<div class="absolute right-2 sm:right-3 top-1/2 -translate-y-1/2 pointer-events-none">
					<svg class="w-3 h-3 sm:w-4 sm:h-4 text-(--color-secondary)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M19 9l-7 7-7-7"></path>
					</svg>
				</div>
			</div>
		</div>
		<button 
			type="submit" 
			class="bg-(--color-primary) hover:bg-[#00c157] text-white px-6 sm:px-8 py-4 md:py-5 text-sm sm:text-base md:text-lg font-semibold rounded-b-lg sm:rounded-r-lg sm:rounded-bl-none transition-all duration-200 hover:shadow-lg active:scale-[0.98] shadow-xl shrink-0"
			aria-label="Rechercher le domaine"
		>
			Rechercher
		</button>
	</form>
	
	<!-- Message container -->
	<Message id="domain-search-message" type="error" autoHide={true} autoHideDuration={5000} />
</div>

<script>
	// Parse domain to extract extension if present
	function parseDomain(input: string, fallbackExtension: string, registries: any[]): { domain: string; extension: string } {
		const trimmed = input.trim().toLowerCase();
		
		// Sort registries by extension length (longest first) to match more specific extensions first
		const sortedRegistries = [...registries].sort((a, b) => b.extension.length - a.extension.length);
		
		// Check if input has any valid extension
		for (const registry of sortedRegistries) {
			if (trimmed.endsWith(registry.extension)) {
				return {
					domain: trimmed.slice(0, -registry.extension.length),
					extension: registry.extension
				};
			}
		}
		
		// No extension found, use fallback
		return {
			domain: trimmed,
			extension: fallbackExtension
		};
	}

	// Validate domain name
	function validateDomain(domain: string): { valid: boolean; error?: string } {
		const validDomainPattern = /^[a-z0-9]([a-z0-9-]*[a-z0-9])?$/i;
		
		if (domain.length < 2) {
			return { valid: false, error: 'Le nom de domaine doit contenir au moins 2 caractères' };
		}
		
		if (domain.length > 63) {
			return { valid: false, error: 'Le nom de domaine ne peut pas dépasser 63 caractères' };
		}
		
		if (!validDomainPattern.test(domain)) {
			return { valid: false, error: 'Le nom de domaine ne peut contenir que des lettres, chiffres et tirets' };
		}
		
		return { valid: true };
	}

	// Use global message utility functions
	const MESSAGE_ID = 'domain-search-message';
	
	function showError(message: string) {
		if (window.showMessage) {
			window.showMessage(MESSAGE_ID, message, 'error');
		}
	}

	function hideError() {
		if (window.hideMessage) {
			window.hideMessage(MESSAGE_ID);
		}
	}

	// Initialize form
	document.addEventListener('DOMContentLoaded', () => {
		const form = document.querySelector('.domain-search-form') as HTMLFormElement;
		if (!form) return;

		const input = form.querySelector('#domain-search') as HTMLInputElement;
		const select = form.querySelector('#registry-select') as HTMLSelectElement;
		const registriesData = JSON.parse(form.dataset.registries || '[]');

		// Hide error when user starts typing
		input.addEventListener('input', hideError);

		// Handle extension change to update placeholder
		select.addEventListener('change', () => {
			const selectedOption = select.options[select.selectedIndex];
			const newPlaceholder = selectedOption.dataset.placeholder;
			if (newPlaceholder && input) {
				input.placeholder = newPlaceholder;
			}
			hideError();
		});

		// Handle form submission
		form.addEventListener('submit', (e) => {
			e.preventDefault();
			
			const trimmedInput = input.value.trim();
			if (!trimmedInput) {
				return;
			}
			
			const selectedExtension = select.value;
			
			// Parse domain and extension
			const { domain, extension } = parseDomain(trimmedInput, selectedExtension, registriesData);
			
			// Validate domain
			const validation = validateDomain(domain);
			if (!validation.valid) {
				showError(validation.error || 'Erreur de validation');
				input.focus();
				return;
			}
			
			// Build full domain and redirect
			const fullDomain = domain + extension;
			window.location.href = `/domain?domain=${encodeURIComponent(fullDomain)}`;
		});
	});
</script>

