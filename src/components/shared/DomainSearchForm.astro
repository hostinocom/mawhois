---
import Message from '../ui/Message.astro';

interface Registry {
	code: string;
	name: string;
	placeholder: string;
	extension: string;
}

interface Props {
	registries: Registry[];
	baseRoute: string;
	searchButtonText: string;
}

const { registries, baseRoute, searchButtonText } = Astro.props;
const defaultRegistry = registries[0];
---


<div class="search-container">
	<form 
		class="domain-search-form search-wrapper"
		role="search" 
		aria-label="Recherche de domaine"
		data-registries={JSON.stringify(registries)}
	>
		<input 
			type="text" 
			id="domain-search"
			name="domain"
			class="search-input" 
			placeholder={defaultRegistry.placeholder}
			required
			minlength="2"
			maxlength="63"
			autocapitalize="off"
			autocomplete="off"
			spellcheck="false"
			autofocus
			aria-label="Rechercher un domaine"
		/>
		<div class="select-wrapper">
			<select 
				id="registry-select"
				name="registry"
				class="domain-select" 
				aria-label="Sélectionner l'extension"
			>
				{registries.map(registry => (
					<option value={registry.extension} data-placeholder={registry.placeholder}>
						{registry.extension}
					</option>
				))}
			</select>
			<!-- Custom dropdown arrow -->
			<div class="select-arrow">
				<svg class="arrow-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M19 9l-7 7-7-7"></path>
				</svg>
			</div>
		</div>
		<button 
			type="submit" 
			class="search-btn"
			aria-label="Rechercher le domaine"
		>
			<span class="button-text">{searchButtonText}</span>
			<span class="button-loader">
				<svg class="spinner" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
					<circle cx="12" cy="12" r="10" stroke="#FFFFFF" stroke-width="3" fill="none" opacity="0.25"></circle>
					<path d="M12 2a10 10 0 0 1 10 10" stroke="#FFFFFF" stroke-width="3" fill="none" stroke-linecap="round"></path>
				</svg>
			</span>
		</button>
	</form>

<style>
	:root {
		--navy-deep: #0A1628;
		--accent-green: #00E676;
		--accent-green-glow: rgba(0, 230, 118, 0.3);
		--text-primary: #FFFFFF;
		--text-muted: rgba(255, 255, 255, 0.7);
		--border-subtle: rgba(255, 255, 255, 0.1);
	}

	/* Search Section */
	.search-container {
		width: 100%;
		max-width: 720px;
		margin: 0 auto;
		opacity: 1;
	}

	.search-wrapper,
	.domain-search-form {
		position: relative;
		background: rgba(255, 255, 255, 0.05);
		border: 1.5px solid var(--border-subtle);
		border-radius: 16px;
		padding: 0.5rem;
		backdrop-filter: blur(20px);
		display: flex;
		gap: 0.5rem;
		transition: all 0.3s ease;
		box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
	}

	.search-wrapper:focus-within,
	.domain-search-form:focus-within {
		border-color: var(--accent-green);
		box-shadow: 0 0 0 4px var(--accent-green-glow), 0 10px 40px rgba(0, 0, 0, 0.3);
	}

	/* Mobile responsive */
	@media (max-width: 640px) {
		.search-wrapper,
		.domain-search-form {
			flex-wrap: wrap;
		}

		.search-input {
			flex: 1;
			min-width: 0;
		}

		.select-wrapper {
			flex-shrink: 0;
		}

		.search-btn {
			width: 100%;
			flex-basis: 100%;
		}
	}

	.search-input {
		flex: 1;
		background: transparent;
		border: none;
		padding: 1.25rem 1.5rem;
		font-size: 1.1rem;
		color: var(--text-primary);
		font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
		outline: none;
	}

	.search-input::placeholder {
		color: var(--text-muted);
		text-transform: none;
	}

	.select-wrapper {
		position: relative;
		display: flex;
		align-items: center;
	}

	.domain-select {
		background: rgba(255, 255, 255, 0.08);
		border: none;
		padding: 1.25rem 1.5rem;
		padding-right: 3rem;
		border-radius: 10px;
		color: var(--text-primary);
		font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
		font-size: 1rem;
		font-weight: 600;
		cursor: pointer;
		outline: none;
		transition: all 0.3s ease;
		min-width: 100px;
		appearance: none;
	}

	.domain-select:hover {
		background: rgba(255, 255, 255, 0.12);
	}

	.domain-select option {
		background: var(--navy-deep);
		color: var(--text-primary);
	}

	/* Remove default select arrow in IE */
	.domain-select::-ms-expand {
		display: none;
	}

	.select-arrow {
		position: absolute;
		right: 1rem;
		top: 50%;
		transform: translateY(-50%);
		pointer-events: none;
		display: flex;
		align-items: center;
		justify-content: center;
	}

	.arrow-icon {
		width: 1rem;
		height: 1rem;
		color: var(--text-primary);
	}

	.search-btn {
		background: var(--accent-green);
		color: #022545;
		border: none;
		padding: 1.25rem 2.5rem;
		border-radius: 12px;
		font-size: 1.05rem;
		font-weight: 700;
		cursor: pointer;
		transition: all 0.3s ease;
		box-shadow: 0 0 25px var(--accent-green-glow);
		font-family: 'Manrope', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
		position: relative;
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 0.5rem;
	}

	.search-btn:hover {
		transform: translateY(-2px);
		box-shadow: 0 0 35px var(--accent-green-glow), 0 8px 20px rgba(0, 0, 0, 0.3);
	}

	.search-btn:active {
		transform: translateY(0);
	}

	.search-btn.loading {
		cursor: not-allowed;
		pointer-events: none;
	}

	.button-text {
		display: inline-block;
	}

	.button-loader {
		display: none !important;
		align-items: center;
		justify-content: center;
	}

	.search-btn.loading .button-text {
		display: none !important;
	}

	.search-btn.loading .button-loader {
		display: inline-flex !important;
	}

	.spinner {
		width: 1.5rem;
		height: 1.5rem;
		animation: spin 0.8s linear infinite;
		display: block;
	}

	@keyframes spin {
		from {
			transform: rotate(0deg);
		}
		to {
			transform: rotate(360deg);
		}
	}

	/* Input autofill styling */
	.search-input:-webkit-autofill,
	.search-input:-webkit-autofill:hover,
	.search-input:-webkit-autofill:focus {
		-webkit-text-fill-color: var(--text-primary);
		-webkit-box-shadow: 0 0 0px 1000px rgba(255, 255, 255, 0.05) inset;
		transition: background-color 5000s ease-in-out 0s;
	}
</style>

<script>
	// Add input focus animation
	const searchInput = document.querySelector('.search-input');
	const searchWrapper = document.querySelector('.search-wrapper, .domain-search-form');

	if (searchInput && searchWrapper && searchInput instanceof HTMLInputElement && searchWrapper instanceof HTMLElement) {
		searchInput.addEventListener('focus', () => {
			searchWrapper.style.transform = 'scale(1.02)';
		});
		
		searchInput.addEventListener('blur', () => {
			searchWrapper.style.transform = 'scale(1)';
		});
	}

	// Update placeholder when registry changes
	const registrySelect = document.getElementById('registry-select');
	const domainInput = document.getElementById('domain-search');

	if (registrySelect && domainInput && registrySelect instanceof HTMLSelectElement && domainInput instanceof HTMLInputElement) {
		registrySelect.addEventListener('change', (e) => {
			const target = e.target;
			if (target && target instanceof HTMLSelectElement) {
				const selectedOption = target.options[target.selectedIndex];
				const placeholder = selectedOption.getAttribute('data-placeholder');
				if (placeholder) {
					domainInput.placeholder = placeholder;
				}
			}
		});
	}

	// Convert input to lowercase as user types
	if (domainInput && domainInput instanceof HTMLInputElement) {
		domainInput.addEventListener('input', (e) => {
			const target = e.target;
			if (target && target instanceof HTMLInputElement) {
				const start = target.selectionStart;
				const end = target.selectionEnd;
				target.value = target.value.toLowerCase();
				if (start !== null && end !== null) {
					target.setSelectionRange(start, end);
				}
			}
		});
	}

	// Handle form submission and loading state - REMOVED
	// Logic moved to main script to synchronize with validation
</script>
	<!-- Message container -->
	<Message id="domain-search-message" type="error" autoHide={true} autoHideDuration={5000} />
</div>

<script define:vars={{ baseRoute }}>
	// Parse domain to extract extension if present
	function parseDomain(input, fallbackExtension, registries) {
		let trimmed = input.trim().toLowerCase();
		
		// Remove leading slashes
		trimmed = trimmed.replace(/^\/+/g, '');
		
		// Extract domain from URL if input is a full URL
		try {
			// Check if input looks like a URL (contains protocol or starts with www.)
			if (trimmed.includes('://') || trimmed.startsWith('www.')) {
				// If it doesn't have a protocol, add http:// for URL parsing
				const urlString = trimmed.includes('://') ? trimmed : `http://${trimmed}`;
				const url = new URL(urlString);
				
				// Extract hostname (domain)
				let hostname = url.hostname;
				
				// Remove www. prefix if present
				hostname = hostname.replace(/^www\./i, '');
				
				trimmed = hostname;
			}
		} catch (error) {
			// If URL parsing fails, continue with the original trimmed input
			// This handles cases where it's not a valid URL format
		}
		
		// Sort registries by extension length (longest first) to match more specific extensions first
		const sortedRegistries = [...registries].sort((a, b) => b.extension.length - a.extension.length);
		
		// Check if input has any valid extension
		for (const registry of sortedRegistries) {
			if (trimmed.endsWith(registry.extension)) {
				return {
					domain: trimmed.slice(0, -registry.extension.length),
					extension: registry.extension
				};
			}
		}
		
		// No extension found, use fallback
		return {
			domain: trimmed,
			extension: fallbackExtension
		};
	}

	// Validate domain name
	function validateDomain(domain) {
		const validDomainPattern = /^[a-z0-9]([a-z0-9-]*[a-z0-9])?$/i;
		
		if (domain.length < 2) {
			return { valid: false, error: 'Le nom de domaine doit contenir au moins 2 caractères' };
		}
		
		if (domain.length > 63) {
			return { valid: false, error: 'Le nom de domaine ne peut pas dépasser 63 caractères' };
		}
		
		if (!validDomainPattern.test(domain)) {
			return { valid: false, error: 'Le nom de domaine ne peut contenir que des lettres, chiffres et tirets' };
		}
		
		return { valid: true };
	}

	// Use global message utility functions
	const MESSAGE_ID = 'domain-search-message';
	
	function showError(message) {
		if (window.showMessage) {
			window.showMessage(MESSAGE_ID, message, 'error');
		}
	}

	function hideError() {
		if (window.hideMessage) {
			window.hideMessage(MESSAGE_ID);
		}
	}

	// Initialize form
	document.addEventListener('DOMContentLoaded', () => {
		const form = document.querySelector('.domain-search-form');
		if (!form || !(form instanceof HTMLFormElement)) return;

		const input = form.querySelector('#domain-search');
		const select = form.querySelector('#registry-select');
		if (!input || !(input instanceof HTMLInputElement)) return;
		if (!select || !(select instanceof HTMLSelectElement)) return;

		const registriesData = JSON.parse(form.dataset.registries || '[]');

		// Hide error when user starts typing
		input.addEventListener('input', hideError);

		// Handle extension change to update placeholder
		select.addEventListener('change', () => {
			const selectedOption = select.options[select.selectedIndex];
			const newPlaceholder = selectedOption.dataset.placeholder;
			if (newPlaceholder && input) {
				input.placeholder = newPlaceholder;
			}
			hideError();
		});

		const submitButton = form.querySelector('.search-btn');

		// Reset button state on page load (handles bfcache/history back)
		window.addEventListener('pageshow', (event) => {
			if (submitButton) {
				submitButton.classList.remove('loading');
			}
		});

		// Handle form submission
		form.addEventListener('submit', (e) => {
			e.preventDefault();
			
			const trimmedInput = input.value.trim();
			if (!trimmedInput) {
				return;
			}
			
			const selectedExtension = select.value;
			
			// Parse domain and extension
			const { domain, extension } = parseDomain(trimmedInput, selectedExtension, registriesData);
			
			// Validate domain
			const validation = validateDomain(domain);
			if (!validation.valid) {
				showError(validation.error || 'Erreur de validation');
				input.focus();
				return;
			}

			// Show loading state only after validation passes
			if (submitButton) {
				submitButton.classList.add('loading');
			}
			
			async function loadSignature(fullDomain) {
				try {
					const response = await fetch('/api/search', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({ fullDomain }),
					});
					const data = await response.json();
					if (data.success) {
						window.location.href = `${baseRoute}/${encodeURIComponent(fullDomain)}?sig=${data.signature}`;
					} else {
						showError(data.error || 'Une erreur est survenue');
						// Reset loading state on API error
						if (submitButton) {
							submitButton.classList.remove('loading');
						}
					}
				} catch (error) {
					showError('Une erreur est survenue');
					// Reset loading state on network error
					if (submitButton) {
						submitButton.classList.remove('loading');
					}
				}
			}
			loadSignature(domain + extension);

		});
	});
</script>

